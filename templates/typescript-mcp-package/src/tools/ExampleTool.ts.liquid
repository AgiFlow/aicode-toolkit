/**
 * {{ toolName }}
 * 
 * DESIGN PATTERNS:
 * - Tool pattern with name, description, inputSchema, and execute method
 * - Service delegation for business logic
 * - JSON Schema validation for inputs
 * 
 * CODING STANDARDS:
 * - Implement Tool interface from ../types
 * - Use snake_case for tool name property (e.g., 'file_read')
 * - Return ToolResult with content array
 * - Handle errors with isError flag
 * - Delegate complex logic to services
 * 
 * AVOID:
 * - Complex business logic in execute method
 * - Unhandled promise rejections
 * - Missing input validation
 */

import type { Tool, ToolResult } from '../types/index';{% if serviceName %}
import { {{ serviceName }} } from '../services/{{ serviceName }}';{% endif %}

interface {{ toolName }}Input {
  input: string;
}

export class {{ toolName }} implements Tool<{{ toolName }}Input, ToolResult> {
  name = '{{ toolName | replace: "Tool", "" | snakeCase }}';
  description = '{{ toolDescription }}';
  inputSchema = {
    type: 'object',
    properties: {
      input: {
        type: 'string',
        description: 'Input data',
      },
    },
    required: ['input'],
  };
{% if serviceName %}
  private service = new {{ serviceName }}();
{% endif %}
  async execute(input: {{ toolName }}Input): Promise<ToolResult> {
    try {
      {% if serviceName %}const result = await this.service.processData(input.input);{% else %}// TODO: Implement tool logic
      const result = input.input;{% endif %}

      return {
        content: [
          {
            type: 'text',
            text: result,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text',
            text: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`,
          },
        ],
        isError: true,
      };
    }
  }
}