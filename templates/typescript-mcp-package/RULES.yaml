version: '1.0'
template: typescript-mcp-package
description: Rules and patterns for typescript-mcp-package template

rules:
  - pattern: src/tools/**/*.ts
    description: MCP Tool Implementation Standards
    inherits:
      - export-standards
      - error-handling
      - type-safety
      - documentation-standards
    must_do:
      - rule: Implement Tool interface with getDefinition and execute
        codeExample: |
          // ✅ GOOD
          export class MyTool implements Tool<MyToolInput> {
            static readonly TOOL_NAME = 'my-tool';

            getDefinition(): ToolDefinition {
              return {
                name: MyTool.TOOL_NAME,
                description: 'Tool description',
                inputSchema: { /* JSON schema */ }
              };
            }

            async execute(input: MyToolInput): Promise<CallToolResult> {
              // Delegate to service
            }
          }
      - rule: Use static TOOL_NAME constant with snake_case naming
        codeExample: |
          // ✅ GOOD
          static readonly TOOL_NAME = 'file_read';
          static readonly TOOL_NAME = 'code_review';

          // ❌ BAD
          static readonly TOOL_NAME = 'FileRead';  // Wrong: should be snake_case
          static readonly toolName = 'file-read';   // Wrong: not static readonly
      - rule: Delegate business logic to services
        codeExample: |
          // ✅ GOOD
          async execute(input: MyToolInput): Promise<CallToolResult> {
            try {
              const result = await this.myService.processData(input);
              return {
                content: [{ type: 'text', text: JSON.stringify(result) }]
              };
            } catch (error) {
              return {
                content: [{ type: 'text', text: error.message }],
                isError: true
              };
            }
          }

          // ❌ BAD - complex logic in execute
          async execute(input: MyToolInput): Promise<CallToolResult> {
            const data = await fs.readFile(input.path);
            const parsed = JSON.parse(data);
            const filtered = parsed.items.filter(x => x.active);
            // ... 50 more lines of business logic
          }
      - rule: Handle errors with isError flag
        codeExample: |
          // ✅ GOOD
          catch (error) {
            return {
              content: [{
                type: 'text',
                text: JSON.stringify({ error: error.message })
              }],
              isError: true
            };
          }
    should_do:
      - rule: Add comprehensive input validation via JSON Schema
        codeExample: |
          inputSchema: {
            type: 'object',
            properties: {
              file_path: {
                type: 'string',
                description: 'Path to the file',
                minLength: 1
              }
            },
            required: ['file_path'],
            additionalProperties: false
          }
      - rule: Include JSDoc comments for complex logic
    must_not_do:
      - rule: Put complex business logic in execute method
        codeExample: |
          // ❌ BAD - 100+ lines of file processing, YAML parsing, validation
          async execute(input: Input): Promise<CallToolResult> {
            const path = input.template_name
              ? join(templatesRoot, input.template_name)
              : join(templatesRoot, 'global');
            // ... 100 more lines of business logic
          }

          // ✅ GOOD - thin orchestration layer
          async execute(input: Input): Promise<CallToolResult> {
            try {
              const result = await this.rulesService.addRule(input);
              return {
                content: [{ type: 'text', text: JSON.stringify(result) }]
              };
            } catch (error) {
              return this.handleError(error);
            }
          }
      - rule: Skip error handling
      - rule: Use hardcoded values - use configuration or constants

  - pattern: src/services/**/*.ts
    description: Service Layer Implementation Standards
    inherits:
      - export-standards
      - error-handling
      - type-safety
      - documentation-standards
      - naming-conventions
    must_do:
      - rule: Create service classes with clear single responsibility
        codeExample: |
          // ✅ GOOD
          export class TemplateFinderService {
            async findTemplateForFile(filePath: string): Promise<TemplateMapping> {
              // Implementation
            }
          }
      - rule: Use dependency injection for other services
        codeExample: |
          // ✅ GOOD
          export class CodeReviewService {
            constructor(
              private ruleFinder: RuleFinder,
              private llmService: ClaudeCodeLLMService
            ) {}
          }
      - rule: Return typed results - never use implicit any
        codeExample: |
          // ✅ GOOD
          async processData(input: string): Promise<ProcessedResult> {
            return { success: true, data: processed };
          }
    must_not_do:
      - rule: Create static-only utility classes - use functions instead
        codeExample: |
          // ❌ BAD
          export class StringUtils {
            static capitalize(str: string) { }
            static trim(str: string) { }
          }

          // ✅ GOOD
          export function capitalize(str: string): string { }
          export function trim(str: string): string { }
      - rule: Mix multiple concerns in one service
      - rule: Use synchronous blocking operations for I/O

  - pattern: src/cli/**/*.ts
    description: CLI Command Implementation Standards
    inherits:
      - export-standards
      - error-handling
      - type-safety
      - async-await-patterns
    must_do:
      - rule: Use Commander.js pattern with async action handlers
        codeExample: |
          // ✅ GOOD
          export const myCommand = new Command('my-command')
            .description('Command description')
            .argument('<arg>', 'Argument description')
            .option('-v, --verbose', 'Enable verbose output')
            .action(async (arg: string, options: Options) => {
              try {
                // Implementation
              } catch (error) {
                console.error('Error:', error);
                process.exit(1);
              }
            });
      - rule: Handle errors gracefully with process.exit()
        codeExample: |
          // ✅ GOOD
          catch (error) {
            console.error('❌ Error:', error.message);
            process.exit(1);
          }
      - rule: Provide clear option descriptions and default values
    must_not_do:
      - rule: Use synchronous blocking operations in action handlers
      - rule: Missing error handling - always use try-catch
      - rule: Hardcode values - use options or environment variables

  - pattern: src/index.ts
    description: Main entry point standards
    inherits:
      - export-standards
      - error-handling
    must_do:
      - rule: Export all public APIs and tools
      - rule: Register all CLI commands in main program
        codeExample: |
          // ✅ GOOD
          import { myCommand } from './cli/my-command';

          program.addCommand(myCommand);
      - rule: Include shebang for executable scripts
        codeExample: |
          #!/usr/bin/env node
    must_not_do:
      - rule: Hardcode command logic in index.ts - use separate command files

  - pattern: src/server/index.ts
    description: MCP Server setup standards
    inherits:
      - export-standards
      - error-handling
    must_do:
      - rule: Register all tools in ListToolsRequestSchema handler
        codeExample: |
          // ✅ GOOD
          server.setRequestHandler(ListToolsRequestSchema, async () => ({
            tools: [
              myTool.getDefinition(),
              otherTool.getDefinition(),
            ],
          }));
      - rule: Handle tool calls in CallToolRequestSchema handler
        codeExample: |
          // ✅ GOOD
          server.setRequestHandler(CallToolRequestSchema, async (request) => {
            const { name, arguments: args } = request.params;

            if (name === MyTool.TOOL_NAME) {
              return await myTool.execute(args as any);
            }

            throw new Error(`Unknown tool: ${name}`);
          });
      - rule: Initialize tools with optional configuration
    must_not_do:
      - rule: Skip error handling for tool execution

  - pattern: tests/**/*.test.ts
    description: Test file standards
    inherits:
      - naming-conventions
      - type-safety
    must_do:
      - rule: Use descriptive test names with 'should...' pattern
        codeExample: |
          // ✅ GOOD
          it('should return user when valid ID is provided', () => {
            // Test implementation
          });
      - rule: Mock external dependencies and services
        codeExample: |
          // ✅ GOOD
          const mockService = {
            getData: vi.fn().mockResolvedValue({ data: 'test' })
          };
      - rule: Test both success and error paths
    should_do:
      - rule: Test input validation
      - rule: Verify return value structure
      - rule: Check edge cases and boundary conditions
