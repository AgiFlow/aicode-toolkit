version: '1.0'
template: typescript-mcp-package
description: Rules and patterns for typescript-mcp-package template
rules:
  - pattern: src/tools/**/*.ts
    description: MCP Tool Implementation Standards
    inherits:
      - import-standards
      - export-standards
      - error-handling
      - type-safety
      - documentation-standards
      - constants-usage
    must_do:
      - rule: Implement Tool interface with getDefinition and execute
        codeExample: |
          // ‚úÖ GOOD
          export class MyTool implements Tool<MyToolInput> {
            static readonly TOOL_NAME = 'my-tool';

            getDefinition(): ToolDefinition {
              return {
                name: MyTool.TOOL_NAME,
                description: 'Tool description',
                inputSchema: { /* JSON schema */ }
              };
            }

            async execute(input: MyToolInput): Promise<CallToolResult> {
              // Delegate to service
            }
          }
      - rule: Use static TOOL_NAME constant with snake_case naming
        codeExample: |
          // ‚úÖ GOOD
          static readonly TOOL_NAME = 'file_read';
          static readonly TOOL_NAME = 'code_review';

          // ‚ùå BAD
          static readonly TOOL_NAME = 'FileRead';  // Wrong: should be snake_case
          static readonly toolName = 'file-read';   // Wrong: not static readonly
      - rule: Delegate business logic to services
        codeExample: |
          // ‚úÖ GOOD
          async execute(input: MyToolInput): Promise<CallToolResult> {
            try {
              const result = await this.myService.processData(input);
              return {
                content: [{ type: 'text', text: JSON.stringify(result) }]
              };
            } catch (error) {
              return {
                content: [{ type: 'text', text: error.message }],
                isError: true
              };
            }
          }

          // ‚ùå BAD - complex logic in execute
          async execute(input: MyToolInput): Promise<CallToolResult> {
            const data = await fs.readFile(input.path);
            const parsed = JSON.parse(data);
            const filtered = parsed.items.filter(x => x.active);
            // ... 50 more lines of business logic
          }
      - rule: Handle errors with isError flag
        codeExample: |
          // ‚úÖ GOOD
          catch (error) {
            return {
              content: [{
                type: 'text',
                text: JSON.stringify({ error: error.message })
              }],
              isError: true
            };
          }
    should_do:
      - rule: Add comprehensive input validation via JSON Schema
        codeExample: |
          inputSchema: {
            type: 'object',
            properties: {
              file_path: {
                type: 'string',
                description: 'Path to the file',
                minLength: 1
              }
            },
            required: ['file_path'],
            additionalProperties: false
          }
      - rule: Include JSDoc comments for complex logic
    must_not_do:
      - rule: Put complex business logic in execute method
        codeExample: |
          // ‚ùå BAD - 100+ lines of file processing, YAML parsing, validation
          async execute(input: Input): Promise<CallToolResult> {
            const path = input.template_name
              ? join(templatesRoot, input.template_name)
              : join(templatesRoot, 'global');
            // ... 100 more lines of business logic
          }

          // ‚úÖ GOOD - thin orchestration layer
          async execute(input: Input): Promise<CallToolResult> {
            try {
              const result = await this.rulesService.addRule(input);
              return {
                content: [{ type: 'text', text: JSON.stringify(result) }]
              };
            } catch (error) {
              return this.handleError(error);
            }
          }
      - rule: Skip error handling
  - pattern: src/services/*/*.ts
    description: Service Layer Implementation Standards
    inherits:
      - import-standards
      - export-standards
      - error-handling
      - type-safety
      - documentation-standards
      - naming-conventions
      - constants-usage
    must_do:
      - rule: Organize each service in its own folder with PascalCase naming
        codeExample: |
          // ‚úÖ GOOD - Service folder structure
          src/services/UserService/
            index.ts           # Barrel export
            types.ts           # Type definitions
            UserService.ts     # Implementation

          src/services/CSSClasses/
            index.ts
            types.ts
            BaseCSSClassesService.ts
            TailwindCSSClassesService.ts

          // ‚ùå BAD - Flat files without folder structure
          src/services/UserService.ts
          src/services/userService.ts
      - rule: Include index.ts barrel export in each service folder
        codeExample: |
          // ‚úÖ GOOD - src/services/UserService/index.ts
          export { UserService } from './UserService';
          export type { UserServiceConfig, UserServiceResult } from './types';
      - rule: Include types.ts for service type definitions
        codeExample: |
          // ‚úÖ GOOD - src/services/UserService/types.ts
          export interface UserServiceConfig {
            verbose?: boolean;
          }

          export interface UserServiceResult {
            success: boolean;
            data?: unknown;
            error?: string;
          }
      - rule: Create service classes with clear single responsibility
        codeExample: |
          // ‚úÖ GOOD
          export class TemplateFinderService {
            async findTemplateForFile(filePath: string): Promise<TemplateMapping> {
              // Implementation
            }
          }
      - rule: Use dependency injection for other services
        codeExample: |
          // ‚úÖ GOOD
          export class CodeReviewService {
            constructor(
              private ruleFinder: RuleFinder,
              private llmService: ClaudeCodeLLMService
            ) {}
          }
      - rule: Return typed results - never use implicit any
        codeExample: |
          // ‚úÖ GOOD
          async processData(input: string): Promise<ProcessedResult> {
            return { success: true, data: processed };
          }
    must_not_do:
      - rule: Create flat service files without folder structure
        codeExample: |
          // ‚ùå BAD - Flat file
          src/services/UserService.ts

          // ‚úÖ GOOD - Folder structure
          src/services/UserService/
            index.ts
            types.ts
            UserService.ts
      - rule: Create static-only utility classes - use functions instead
        codeExample: |
          // ‚ùå BAD
          export class StringUtils {
            static capitalize(str: string) { }
            static trim(str: string) { }
          }

          // ‚úÖ GOOD
          export function capitalize(str: string): string { }
          export function trim(str: string): string { }
      - rule: Mix multiple concerns in one service
      - rule: Use synchronous blocking operations for I/O
  - pattern: src/commands/**/*.ts
    description: CLI Command Implementation Standards
    inherits:
      - import-standards
      - export-standards
      - error-handling
      - type-safety
      - async-await-patterns
    must_do:
      - rule: Use Commander.js pattern with async action handlers
        codeExample: |
          // ‚úÖ GOOD
          export const myCommand = new Command('my-command')
            .description('Command description')
            .argument('<arg>', 'Argument description')
            .option('-v, --verbose', 'Enable verbose output')
            .action(async (arg: string, options: Options) => {
              try {
                // Implementation
              } catch (error) {
                console.error('Error:', error);
                process.exit(1);
              }
            });
      - rule: Handle errors gracefully with process.exit()
        codeExample: |
          // ‚úÖ GOOD
          catch (error) {
            console.error('‚ùå Error:', error.message);
            process.exit(1);
          }
      - rule: Provide clear option descriptions and default values
    must_not_do:
      - rule: Use synchronous blocking operations in action handlers
      - rule: Missing error handling - always use try-catch
      - rule: Hardcode values - use options or environment variables
  - pattern: src/index.ts
    description: Main barrel export file for public API
    inherits:
      - import-standards
      - export-standards
    must_do:
      - rule: Export all public-facing modules using named exports
        codeExample: |-
          // ‚úÖ GOOD - Named exports
          export { server } from './server/index';
          export type * from './types/index';
          export { MyTool } from './tools/MyTool';
          export { MyService } from './services/MyService';
      - rule: Group exports by category with comments
        codeExample: |-
          // Server
          export { server } from './server/index';

          // Types
          export type * from './types/index';

          // Tools
          export { MyTool } from './tools/MyTool';
      - rule: Use 'export type *' for type-only exports
        codeExample: |-
          // ‚úÖ GOOD
          export type * from './types/index';

          // ‚ùå BAD
          export * from './types/index';
    must_not_do:
      - rule: Export CLI or command-related modules
        codeExample: |-
          // ‚ùå BAD - CLI is for bin usage only
          export { mcpServeCommand } from './commands/mcp-serve';

          // ‚úÖ GOOD - Only library/server API
          export { server } from './server/index';
      - rule: Use wildcard exports (be explicit)
        codeExample: |-
          // ‚ùå BAD
          export * from './tools/index';

          // ‚úÖ GOOD
          export { Tool1, Tool2 } from './tools/index';
      - rule: Use default exports
      - rule: Export internal implementation details
  - pattern: src/cli.ts
    description: Main CLI entry point standards
    inherits:
      - import-standards
      - export-standards
      - error-handling
    must_do:
      - rule: Register all CLI commands in main program
        codeExample: |
          // ‚úÖ GOOD
          import { myCommand } from './commands/my-command';

          program.addCommand(myCommand);
      - rule: Include shebang for executable scripts
        codeExample: |
          #!/usr/bin/env node
    must_not_do:
      - rule: Hardcode command logic in cli.ts - use separate command files
  - pattern: src/server/index.ts
    description: MCP Server setup standards
    inherits:
      - import-standards
      - export-standards
      - error-handling
    must_do:
      - rule: Register all tools in ListToolsRequestSchema handler
        codeExample: |
          // ‚úÖ GOOD
          server.setRequestHandler(ListToolsRequestSchema, async () => ({
            tools: [
              myTool.getDefinition(),
              otherTool.getDefinition(),
            ],
          }));
      - rule: Handle tool calls in CallToolRequestSchema handler
        codeExample: |
          // ‚úÖ GOOD
          server.setRequestHandler(CallToolRequestSchema, async (request) => {
            const { name, arguments: args } = request.params;

            if (name === MyTool.TOOL_NAME) {
              return await myTool.execute(args as any);
            }

            throw new Error(`Unknown tool: ${name}`);
          });
      - rule: Initialize tools with optional configuration
    must_not_do:
      - rule: Skip error handling for tool execution
  - pattern: tests/**/*.test.ts
    description: Test file standards
    inherits:
      - import-standards
      - naming-conventions
      - type-safety
    must_do:
      - rule: Use descriptive test names with 'should...' pattern
        codeExample: |
          // ‚úÖ GOOD
          it('should return user when valid ID is provided', () => {
            // Test implementation
          });
      - rule: Mock external dependencies and services
        codeExample: |
          // ‚úÖ GOOD
          const mockService = {
            getData: vi.fn().mockResolvedValue({ data: 'test' })
          };
      - rule: Test both success and error paths
    should_do:
      - rule: Test input validation
      - rule: Verify return value structure
      - rule: Check edge cases and boundary conditions
  - pattern: src/prompts/**/*.ts
    description: MCP Prompt Implementation Standards
    inherits:
      - import-standards
      - export-standards
      - error-handling
      - type-safety
    must_do:
      - rule: Implement Prompt interface with getDefinition and execute
        codeExample: |-
          export class MyPrompt implements Prompt {
            getDefinition() {
              return {
                name: 'my-prompt',
                description: 'Generate prompt for task',
                arguments: [
                  {
                    name: 'topic',
                    description: 'Topic to analyze',
                    required: true
                  }
                ]
              };
            }

            async execute(args: { topic: string }): Promise<GetPromptResult> {
              return {
                messages: [
                  {
                    role: 'user',
                    content: {
                      type: 'text',
                      text: `Analyze: ${args.topic}`
                    }
                  }
                ]
              };
            }
          }
      - rule: Return GetPromptResult with messages array
        codeExample: |-
          return {
            messages: [
              { role: 'user', content: { type: 'text', text: 'prompt' } }
            ]
          };
      - rule: Define clear prompt arguments with descriptions
        codeExample: |-
          arguments: [
            {
              name: 'context',
              description: 'Context for the prompt',
              required: true
            },
            {
              name: 'format',
              description: 'Output format',
              required: false
            }
          ]
    must_not_do:
      - rule: Return empty messages array
        codeExample: |-
          // ‚ùå BAD
          return { messages: [] };

          // ‚úÖ GOOD
          return {
            messages: [
              { role: 'user', content: { type: 'text', text: prompt } }
            ]
          };
      - rule: Mix multiple concerns in one prompt
        codeExample: |-
          // ‚ùå BAD - Prompt handles code review + testing + docs
          class AllInOnePrompt implements Prompt { }

          // ‚úÖ GOOD - Separate prompts
          class CodeReviewPrompt implements Prompt { }
          class TestGenerationPrompt implements Prompt { }
      - rule: Use hardcoded messages without arguments
  - pattern: src/transports/**/*.ts
    description: MCP Transport Setup Standards
    inherits:
      - import-standards
      - export-standards
      - error-handling
      - async-await-patterns
    must_do:
      - rule: Use async/await for transport connection
        codeExample: |-
          async function main() {
            const transport = new StdioServerTransport();
            await server.connect(transport);
          }

          main().catch((error) => {
            console.error('Server error:', error);
            process.exit(1);
          });
      - rule: Handle connection errors gracefully
        codeExample: |-
          async function startServer() {
            try {
              const transport = new StdioServerTransport();
              await server.connect(transport);
              console.log('Server started successfully');
            } catch (error) {
              console.error('Failed to start server:', error);
              process.exit(1);
            }
          }
      - rule: Import correct transport for use case (Stdio or SSE)
        codeExample: |-
          // For stdio (CLI usage)
          import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';

          // For SSE (HTTP usage)
          import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
    must_not_do:
      - rule: Mix multiple transports in same entry point
        codeExample: |-
          // ‚ùå BAD - Multiple transports
          const stdioTransport = new StdioServerTransport();
          const sseTransport = new SSEServerTransport();
          await server.connect(stdioTransport);
          await server.connect(sseTransport);

          // ‚úÖ GOOD - Separate entry points
          // index.ts - stdio only
          // server-http.ts - SSE only
      - rule: Skip error handling on connect()
        codeExample: |-
          // ‚ùå BAD
          await server.connect(transport); // No error handling

          // ‚úÖ GOOD
          try {
            await server.connect(transport);
          } catch (error) {
            console.error('Connection failed:', error);
            process.exit(1);
          }
      - rule: Use synchronous connection methods
  - pattern: src/types/**/*.ts
    description: Type Definitions and Interfaces Standards
    inherits:
      - import-standards
      - export-standards
      - type-safety
      - documentation-standards
    must_do:
      - rule: Define clear interfaces for all data structures
        codeExample: |-
          export interface ToolInput {
            filePath: string;
            options?: {
              verbose?: boolean;
              format?: 'json' | 'yaml';
            };
          }

          export interface ToolResult {
            success: boolean;
            data?: unknown;
            error?: string;
          }
      - rule: Use TypeScript utility types for type transformations
        codeExample: |-
          export type PartialToolInput = Partial<ToolInput>;
          export type RequiredToolInput = Required<ToolInput>;
          export type ToolInputKeys = keyof ToolInput;

          // Pick specific fields
          export type ToolConfig = Pick<ToolInput, 'options'>;
      - rule: Add JSDoc comments for complex types
        codeExample: |-
          /**
           * Configuration for the MCP tool execution
           * @property timeout - Execution timeout in milliseconds
           * @property retries - Number of retry attempts
           */
          export interface ToolConfig {
            timeout: number;
            retries: number;
          }
      - rule: Use const assertions for literal types
        codeExample: |-
          export const TOOL_CATEGORIES = {
            FILE: 'file',
            CODE: 'code',
            SEARCH: 'search'
          } as const;

          export type ToolCategory = typeof TOOL_CATEGORIES[keyof typeof TOOL_CATEGORIES];
    must_not_do:
      - rule: Use 'any' type - use 'unknown' or proper types
        codeExample: |-
          // ‚ùå BAD
          export interface Result {
            data: any;
          }

          // ‚úÖ GOOD
          export interface Result<T = unknown> {
            data: T;
          }
      - rule: Create types without exports
        codeExample: |-
          // ‚ùå BAD
          interface Config { } // Not exported

          // ‚úÖ GOOD
          export interface Config { }
      - rule: Mix implementation with type definitions
        codeExample: |-
          // ‚ùå BAD - Implementation in types file
          export class MyService { }
          export interface MyInterface { }

          // ‚úÖ GOOD - Only types
          export interface MyInterface { }
          export type MyType = { };
      - rule: Use default exports for types
        codeExample: |-
          // ‚ùå BAD
          export default interface Config { }

          // ‚úÖ GOOD
          export interface Config { }
  - pattern: src/commands/index.ts
    description: CLI Barrel Export Standards
    inherits:
      - import-standards
      - export-standards
    must_do:
      - rule: Export all CLI commands from index.ts using barrel exports
        codeExample: |-
          export { myCommand } from './my-command';
          export { anotherCommand } from './another-command';
          export { utilityCommand } from './utility-command';
      - rule: Use named exports for all commands
        codeExample: |-
          // ‚úÖ GOOD - Named exports
          export { processCommand } from './process';
          export { analyzeCommand } from './analyze';

          // ‚ùå BAD - Default exports
          export { default as processCommand } from './process';
    must_not_do:
      - rule: Include implementation in index.ts - only exports
        codeExample: |-
          // ‚ùå BAD - Implementation in barrel file
          export const myCommand = new Command('my').action(() => {});

          // ‚úÖ GOOD - Only exports
          export { myCommand } from './my-command';
      - rule: Use wildcard exports - be explicit
        codeExample: |-
          // ‚ùå BAD
          export * from './commandss';

          // ‚úÖ GOOD
          export { command1, command2 } from './commands';
  - pattern: src/tools/index.ts
    description: Tools Barrel Export Standards
    inherits:
      - import-standards
      - export-standards
    must_do:
      - rule: Export all tools from index.ts using barrel exports
        codeExample: |-
          export { MyTool } from './MyTool';
          export { AnotherTool } from './AnotherTool';
      - rule: Use named exports for all tools
        codeExample: |-
          // ‚úÖ GOOD
          export { FileTool } from './FileTool';
          export { CodeTool } from './CodeTool';
    must_not_do:
      - rule: Include tool implementation in index.ts
        codeExample: |-
          // ‚ùå BAD
          export class MyTool implements Tool { }

          // ‚úÖ GOOD
          export { MyTool } from './MyTool';
      - rule: Use wildcard exports
        codeExample: |-
          // ‚ùå BAD
          export * from './tools';

          // ‚úÖ GOOD
          export { Tool1, Tool2 } from './tools';
  - pattern: src/services/index.ts
    description: Services Barrel Export Standards
    inherits:
      - import-standards
      - export-standards
    must_do:
      - rule: Export all services from index.ts using barrel exports
        codeExample: |-
          export { UserService } from './UserService';
          export { DataService } from './DataService';
          export { FileService } from './FileService';
      - rule: Group related services together in exports
        codeExample: |-
          // Database services
          export { UserService } from './UserService';
          export { OrderService } from './OrderService';

          // Utility services
          export { LoggerService } from './LoggerService';
          export { CacheService } from './CacheService';
    must_not_do:
      - rule: Include service implementation in index.ts
        codeExample: |-
          // ‚ùå BAD
          export class UserService { }

          // ‚úÖ GOOD
          export { UserService } from './UserService';
      - rule: Use wildcard exports
        codeExample: |-
          // ‚ùå BAD
          export * from './services';

          // ‚úÖ GOOD
          export { Service1, Service2 } from './services';
  - pattern: src/hooks/**/*.ts
    description: Hook Class Implementation Standards
    inherits:
      - import-standards
      - export-standards
      - error-handling
      - type-safety
    must_do:
      - rule: Export a hook class with preToolUse and postToolUse methods
        codeExample: |-
          // ‚úÖ GOOD - Claude Code hook class
          import type { ClaudeCodeHookInput, HookResponse } from '@agiflowai/hooks-adapter';
          import {
            ExecutionLogService,
            DECISION_SKIP,
            DECISION_DENY,
            DECISION_ALLOW,
          } from '@agiflowai/hooks-adapter';

          export class MyFeatureHook {
            async preToolUse(context: ClaudeCodeHookInput): Promise<HookResponse> {
              try {
                // Access Claude Code fields: tool_name, tool_input, session_id, etc.
                const filePath = context.tool_input.file_path;
                return { decision: DECISION_SKIP, message: '' };
              } catch (error) {
                return {
                  decision: DECISION_SKIP,
                  message: `‚ö†Ô∏è Hook error: ${error instanceof Error ? error.message : String(error)}`
                };
              }
            }

            async postToolUse(context: ClaudeCodeHookInput): Promise<HookResponse> {
              try {
                return { decision: DECISION_SKIP, message: '' };
              } catch (error) {
                return {
                  decision: DECISION_SKIP,
                  message: `‚ö†Ô∏è Hook error: ${error instanceof Error ? error.message : String(error)}`
                };
              }
            }
          }
      - rule: Always use fail-open pattern - return SKIP on errors in each method
        codeExample: |-
          // ‚úÖ GOOD
          async preToolUse(context: ClaudeCodeHookInput): Promise<HookResponse> {
            try {
              // Hook logic
              return { decision: DECISION_ALLOW, message: 'Success' };
            } catch (error) {
              return {
                decision: DECISION_SKIP,
                message: `‚ö†Ô∏è Hook error: ${error instanceof Error ? error.message : String(error)}`
              };
            }
          }
      - rule: Use ExecutionLogService instance for session state tracking
        codeExample: |-
          // ‚úÖ GOOD - Instantiate with session_id
          async preToolUse(context: ClaudeCodeHookInput): Promise<HookResponse> {
            const executionLog = new ExecutionLogService(context.session_id);
            const sessionKey = 'my-hook';
            const alreadyProcessed = await executionLog.hasExecuted({
              filePath: sessionKey,
              decision: DECISION_DENY
            });

            if (!alreadyProcessed) {
              await executionLog.logExecution({
                filePath: sessionKey,
                operation: 'my-operation',
                decision: DECISION_DENY
              });
            }
          }
      - rule: Return proper HookResponse with decision and message
        codeExample: |-
          // ‚úÖ GOOD
          return {
            decision: DECISION_DENY,
            message: 'üéØ **Guidance**\n\nProvide helpful guidance here.'
          };
      - rule: Extract file paths and data from tool_input
        codeExample: |-
          // ‚úÖ GOOD - Claude Code
          const filePath = context.tool_input.file_path;
          const content = context.tool_input.content;

          if (!filePath || !['Read', 'Write', 'Edit'].includes(context.tool_name)) {
            return { decision: DECISION_SKIP, message: 'Not a file operation' };
          }
      - rule: Use PascalCase class name with Hook suffix
        codeExample: |-
          // ‚úÖ GOOD
          export class ListScaffoldMethodsHook { }
          export class ValidateInputHook { }
          export class GetFileDesignPatternHook { }

          // ‚ùå BAD
          export class listScaffoldMethods { }  // Wrong: not PascalCase
          export class ListScaffoldMethods { }  // Wrong: missing Hook suffix
    must_not_do:
      - rule: Never throw errors or let errors propagate from methods
        codeExample: |-
          // ‚ùå BAD - Throws error
          async preToolUse(context: ClaudeCodeHookInput) {
            const data = await riskyOperation(); // Can throw
            return { decision: DECISION_ALLOW };
          }

          // ‚úÖ GOOD - Catches and returns SKIP
          async preToolUse(context: ClaudeCodeHookInput): Promise<HookResponse> {
            try {
              const data = await riskyOperation();
              return { decision: DECISION_ALLOW, message: '' };
            } catch (error) {
              return {
                decision: DECISION_SKIP,
                message: `‚ö†Ô∏è Hook error: ${error instanceof Error ? error.message : String(error)}`
              };
            }
          }
      - rule: Never mutate context object
        codeExample: |-
          // ‚ùå BAD
          context.session_id = 'new-id';
          context.tool_input = { modified: true };

          // ‚úÖ GOOD - Read only
          const sessionId = context.session_id;
          const input = context.tool_input;
      - rule: Never use blocking operations without error handling
        codeExample: |-
          // ‚ùå BAD
          const data = fs.readFileSync('/path'); // Blocks and can throw

          // ‚úÖ GOOD
          try {
            const data = await fs.promises.readFile('/path');
          } catch (error) {
            return { decision: DECISION_SKIP, message: 'Error occurred' };
          }
      - rule: Never export standalone functions instead of class
        codeExample: |-
          // ‚ùå BAD - Standalone functions
          export const preToolUseHook = async (context) => { };
          export const postToolUseHook = async (context) => { };

          // ‚úÖ GOOD - Class with methods
          export class MyHook {
            async preToolUse(context) { }
            async postToolUse(context) { }
          }
