features:
  - name: nextjs-page-pattern
    design_pattern: Next.js Page Component Pattern
    includes:
      - src/app/**/page.tsx
    description: |-
      ## Pattern Overview
      Design pattern for Next.js 15 App Router page components using Server Components by default with proper metadata, data fetching, and error handling.

      ## What TO DO ✅

      - Export async Server Components by default for data fetching
      - Export metadata or generateMetadata() for SEO
      - Use proper TypeScript types for params and searchParams
      - Fetch data at the component level using async/await
      - Use Suspense boundaries for loading states
      - Handle errors with error.tsx boundary files
      - Keep components simple and delegate UI to separate components
      - Use absolute imports with @/ alias
      - Follow proper naming: page.tsx exports default function Page()

      ## What NOT TO DO ❌

      - Don't add 'use client' unless absolutely necessary (interactivity needed)
      - Don't fetch data in useEffect hooks in Server Components
      - Don't mix server and client logic in the same component
      - Don't forget to export metadata for SEO
      - Don't use useState/useEffect in Server Components
      - Don't access searchParams synchronously (must be awaited in Next.js 15)
      - Don't put complex UI logic directly in page.tsx

      ## Examples

      ### Basic Page with Metadata
      ```typescript
      import type { Metadata } from 'next';

      export const metadata: Metadata = {
        title: 'Dashboard',
        description: 'User dashboard page',
      };

      export default function DashboardPage() {
        return (
          <main>
            <h1>Dashboard</h1>
          </main>
        );
      }
      ```

      ### Page with Data Fetching
      ```typescript
      import { db } from '@/db/drizzle';
      import { users } from '@/db/schema';

      export default async function UsersPage() {
        const userList = await db.select().from(users);
        
        return (
          <main>
            <h1>Users</h1>
            <UserList users={userList} />
          </main>
        );
      }
      ```

      ### Dynamic Page with Params
      ```typescript
      import type { Metadata } from 'next';

      interface PageProps {
        params: Promise<{ slug: string }>;
        searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
      }

      export async function generateMetadata({ params }: PageProps): Promise<Metadata> {
        const { slug } = await params;
        return {
          title: `Post: ${slug}`,
        };
      }

      export default async function PostPage({ params, searchParams }: PageProps) {
        const { slug } = await params;
        const filters = await searchParams;
        
        return <article>{/* content */}</article>;
      }
      ```
  - name: nextjs-layout-pattern
    design_pattern: Next.js Layout Component Pattern
    includes:
      - src/app/**/layout.tsx
    description: |-
      ## Pattern Overview
      Design pattern for Next.js 15 App Router layout components that wrap child pages with shared UI, metadata, and behavior.

      ## What TO DO ✅

      - Accept children prop and render it in the layout
      - Export metadata at root layout (app/layout.tsx) for site-wide defaults
      - Use Server Components by default
      - Add route group protection logic (auth checks) at layout level
      - Keep layouts focused on structural UI (navigation, sidebars, headers)
      - Use proper TypeScript types for props
      - Apply global styles in root layout only
      - Define font variables in root layout
      - Nest layouts for progressive enhancement

      ## What NOT TO DO ❌

      - Don't forget to render {children} prop
      - Don't add 'use client' unless client-side state is required
      - Don't fetch the same data in both layout and page (hoist to layout)
      - Don't apply global styles in nested layouts
      - Don't create unnecessary layout nesting
      - Don't forget route group redirects for protected routes
      - Don't use layouts for one-off page wrapping (use page composition instead)

      ## Examples

      ### Root Layout with Global Styles
      ```typescript
      import type { Metadata } from 'next';
      import { Inter } from 'next/font/google';
      import '@/app/globals.css';

      const inter = Inter({ subsets: ['latin'] });

      export const metadata: Metadata = {
        title: {
          default: 'My App',
          template: '%s | My App',
        },
        description: 'App description',
      };

      export default function RootLayout({
        children,
      }: {
        children: React.ReactNode;
      }) {
        return (
          <html lang="en">
            <body className={inter.className}>{children}</body>
          </html>
        );
      }
      ```

      ### Protected Route Layout with Auth
      ```typescript
      import { auth } from '@/lib/auth';
      import { redirect } from 'next/navigation';
      import { headers } from 'next/headers';

      export default async function ProtectedLayout({
        children,
      }: {
        children: React.ReactNode;
      }) {
        const session = await auth.api.getSession({
          headers: await headers(),
        });

        if (!session) {
          redirect('/sign-in');
        }

        return (
          <div>
            <nav>{/* Protected nav */}</nav>
            <main>{children}</main>
          </div>
        );
      }
      ```

      ### Nested Layout with Shared UI
      ```typescript
      export default function DashboardLayout({
        children,
      }: {
        children: React.ReactNode;
      }) {
        return (
          <div className="dashboard-grid">
            <aside>{/* Sidebar */}</aside>
            <main>{children}</main>
          </div>
        );
      }
      ```
  - name: nextjs-api-route-pattern
    design_pattern: Next.js API Route Handler Pattern
    includes:
      - src/app/api/**/route.ts
    description: |-
      ## Pattern Overview
      Design pattern for Next.js 15 App Router API routes using Web Request/Response API with proper validation, error handling, and service delegation.

      ## What TO DO ✅

      - Export async functions named after HTTP methods (GET, POST, PUT, DELETE, PATCH)
      - Use NextResponse.json() for JSON responses with proper status codes
      - Validate input with Zod schemas before processing
      - Delegate business logic to services (never access db directly)
      - Handle errors with try-catch and return appropriate status codes
      - Add authentication/authorization checks when needed
      - Use proper TypeScript types for request/response
      - Return consistent response format { success, data?, error? }
      - Add CORS headers for public APIs if needed
      - Use revalidatePath/revalidateTag for cache invalidation

      ## What NOT TO DO ❌

      - Don't put business logic directly in route handlers
      - Don't access database directly (use services instead)
      - Don't forget input validation
      - Don't return raw errors to client (sanitize error messages)
      - Don't forget authentication checks for protected routes
      - Don't use res/req from Next.js 12 (use Request/Response)
      - Don't mix route.ts with page.ts in same segment
      - Don't forget to handle different HTTP methods separately

      ## Examples

      ### Basic GET Route
      ```typescript
      import { NextResponse } from 'next/server';
      import { UserService } from '@/services/UserService';

      export async function GET() {
        try {
          const userService = new UserService();
          const users = await userService.getAll();
          
          return NextResponse.json({ success: true, data: users });
        } catch (error) {
          return NextResponse.json(
            { success: false, error: 'Failed to fetch users' },
            { status: 500 }
          );
        }
      }
      ```

      ### POST Route with Validation
      ```typescript
      import { NextResponse } from 'next/server';
      import { z } from 'zod';
      import { UserService } from '@/services/UserService';

      const createUserSchema = z.object({
        email: z.string().email(),
        name: z.string().min(2),
      });

      export async function POST(request: Request) {
        try {
          const body = await request.json();
          const validatedData = createUserSchema.parse(body);
          
          const userService = new UserService();
          const user = await userService.create(validatedData);
          
          return NextResponse.json(
            { success: true, data: user },
            { status: 201 }
          );
        } catch (error) {
          if (error instanceof z.ZodError) {
            return NextResponse.json(
              { success: false, error: error.errors },
              { status: 400 }
            );
          }
          
          return NextResponse.json(
            { success: false, error: 'Internal server error' },
            { status: 500 }
          );
        }
      }
      ```

      ### Protected Route with Auth
      ```typescript
      import { NextResponse } from 'next/server';
      import { auth } from '@/lib/auth';
      import { headers } from 'next/headers';

      export async function GET() {
        const session = await auth.api.getSession({
          headers: await headers(),
        });
        
        if (!session) {
          return NextResponse.json(
            { success: false, error: 'Unauthorized' },
            { status: 401 }
          );
        }
        
        // Continue with authenticated logic
        return NextResponse.json({ success: true, data: { user: session.user } });
      }
      ```

      ### Dynamic Route with Params
      ```typescript
      import { NextResponse } from 'next/server';
      import { UserService } from '@/services/UserService';

      export async function GET(
        request: Request,
        { params }: { params: Promise<{ id: string }> }
      ) {
        try {
          const { id } = await params;
          const userService = new UserService();
          const user = await userService.getById(id);
          
          if (!user) {
            return NextResponse.json(
              { success: false, error: 'User not found' },
              { status: 404 }
            );
          }
          
          return NextResponse.json({ success: true, data: user });
        } catch (error) {
          return NextResponse.json(
            { success: false, error: 'Internal server error' },
            { status: 500 }
          );
        }
      }
      ```
  - name: react-component-pattern
    design_pattern: React Component Pattern with Tailwind CSS
    includes:
      - src/components/**/*.tsx
      - src/app/**/_ui/components/**/*.tsx
    description: |-
      ## Pattern Overview
      Design pattern for React components with TypeScript, Tailwind CSS, and proper composition patterns. Includes both client and server components with Storybook integration.

      ## What TO DO ✅

      - Use TypeScript with proper interface definitions
      - Export component as default for simpler imports
      - Use cn() utility from @/lib/utils for className merging
      - Add 'use client' directive only when client interactivity is needed
      - Use React.forwardRef for components that need ref access
      - Extend React.ComponentPropsWithoutRef or ComponentPropsWithRef for prop inheritance
      - Keep components focused and single-purpose
      - Use composition over prop drilling
      - Create Storybook stories for component documentation
      - Use Tailwind utility classes for styling
      - Provide sensible prop defaults

      ## What NOT TO DO ❌

      - Don't use inline styles unless absolutely necessary
      - Don't forget 'use client' for components with hooks/events
      - Don't create overly complex prop interfaces
      - Don't mix server and client component logic
      - Don't forget to forward refs when wrapping native elements
      - Don't use CSS modules (use Tailwind instead)
      - Don't create components without TypeScript types
      - Don't skip Storybook stories for reusable components

      ## Examples

      ### Basic Client Component
      ```typescript
      'use client';

      import { cn } from '@/lib/utils';

      interface ButtonProps extends React.ComponentPropsWithoutRef<'button'> {
        variant?: 'primary' | 'secondary';
        size?: 'sm' | 'md' | 'lg';
      }

      export default function Button({
        variant = 'primary',
        size = 'md',
        className,
        children,
        ...props
      }: ButtonProps) {
        return (
          <button
            className={cn(
              'rounded font-medium transition-colors',
              variant === 'primary' && 'bg-blue-600 text-white hover:bg-blue-700',
              variant === 'secondary' && 'bg-gray-200 text-gray-900 hover:bg-gray-300',
              size === 'sm' && 'px-3 py-1 text-sm',
              size === 'md' && 'px-4 py-2',
              size === 'lg' && 'px-6 py-3 text-lg',
              className
            )}
            {...props}
          >
            {children}
          </button>
        );
      }
      ```

      ### Component with ForwardRef
      ```typescript
      'use client';

      import { forwardRef } from 'react';
      import { cn } from '@/lib/utils';

      interface InputProps extends React.ComponentPropsWithRef<'input'> {
        label?: string;
        error?: string;
      }

      const Input = forwardRef<HTMLInputElement, InputProps>(
        ({ label, error, className, ...props }, ref) => {
          return (
            <div className="space-y-1">
              {label && <label className="block text-sm font-medium">{label}</label>}
              <input
                ref={ref}
                className={cn(
                  'w-full rounded border px-3 py-2',
                  error ? 'border-red-500' : 'border-gray-300',
                  className
                )}
                {...props}
              />
              {error && <p className="text-sm text-red-600">{error}</p>}
            </div>
          );
        }
      );

      Input.displayName = 'Input';

      export default Input;
      ```

      ### Server Component (No 'use client')
      ```typescript
      import { cn } from '@/lib/utils';

      interface CardProps {
        title: string;
        description?: string;
        children?: React.ReactNode;
        className?: string;
      }

      export default function Card({
        title,
        description,
        children,
        className,
      }: CardProps) {
        return (
          <div className={cn('rounded-lg border bg-white p-6 shadow-sm', className)}>
            <h3 className="text-lg font-semibold">{title}</h3>
            {description && <p className="mt-1 text-sm text-gray-600">{description}</p>}
            {children && <div className="mt-4">{children}</div>}
          </div>
        );
      }
      ```

      ### Storybook Story Example
      ```typescript
      import type { Meta, StoryObj } from '@storybook/react';
      import Button from './index';

      const meta = {
        title: 'Components/Button',
        component: Button,
        parameters: {
          layout: 'centered',
        },
        tags: ['autodocs'],
      } satisfies Meta<typeof Button>;

      export default meta;
      type Story = StoryObj<typeof meta>;

      export const Playground: Story = {
        args: {
          children: 'Click me',
          variant: 'primary',
          size: 'md',
        },
      };

      export const Primary: Story = {
        args: {
          children: 'Primary Button',
          variant: 'primary',
        },
      };

      export const Secondary: Story = {
        args: {
          children: 'Secondary Button',
          variant: 'secondary',
        },
      };
      ```
  - name: server-action-pattern
    design_pattern: Next.js Server Action Pattern
    includes:
      - src/actions/**/*.ts
      - src/app/**/_ui/actions/**/*.ts
    description: |-
      ## Pattern Overview
      Design pattern for Next.js server actions with 'use server' directive, Zod validation, service delegation, and proper error handling.

      ## What TO DO ✅

      - Add 'use server' directive at the top of the file
      - Export async functions that return result objects
      - Validate input with Zod schemas before processing
      - Delegate business logic to services (NEVER access db directly)
      - Return consistent format: { success: boolean, data?: T, error?: string }
      - Use revalidatePath() or revalidateTag() for cache invalidation
      - Add authentication/authorization checks when needed
      - Handle errors with try-catch blocks
      - Use TypeScript types for inputs and outputs
      - Keep actions thin - validate, call service, revalidate cache

      ## What NOT TO DO ❌

      - Don't access database directly in actions (use services)
      - Don't put complex business logic in actions
      - Don't forget input validation
      - Don't return raw error objects to client
      - Don't skip cache revalidation after mutations
      - Don't forget 'use server' directive
      - Don't expose sensitive data in return values
      - Don't use actions for data fetching (use Server Components instead)
      - Don't trust client-provided data without validation

      ## Examples

      ### Basic Server Action with Validation
      ```typescript
      'use server';

      import { z } from 'zod';
      import { revalidatePath } from 'next/cache';
      import { UserService } from '@/services/UserService';

      const createUserSchema = z.object({
        email: z.string().email(),
        name: z.string().min(2),
      });

      export type CreateUserInput = z.infer<typeof createUserSchema>;

      export async function createUser(input: CreateUserInput) {
        try {
          const validatedData = createUserSchema.parse(input);
          
          const userService = new UserService();
          const user = await userService.create(validatedData);
          
          revalidatePath('/users');
          
          return { success: true, data: user };
        } catch (error) {
          if (error instanceof z.ZodError) {
            return { success: false, error: 'Invalid input data' };
          }
          
          return { success: false, error: 'Failed to create user' };
        }
      }
      ```

      ### Protected Server Action with Auth
      ```typescript
      'use server';

      import { z } from 'zod';
      import { auth } from '@/lib/auth';
      import { headers } from 'next/headers';
      import { revalidatePath } from 'next/cache';
      import { ProductService } from '@/services/ProductService';

      const updateProductSchema = z.object({
        id: z.string(),
        name: z.string().min(1),
        price: z.number().positive(),
      });

      export type UpdateProductInput = z.infer<typeof updateProductSchema>;

      export async function updateProduct(input: UpdateProductInput) {
        try {
          // Check authentication
          const session = await auth.api.getSession({
            headers: await headers(),
          });
          
          if (!session) {
            return { success: false, error: 'Unauthorized' };
          }
          
          // Validate input
          const validatedData = updateProductSchema.parse(input);
          
          // Delegate to service
          const productService = new ProductService();
          const product = await productService.update(
            validatedData.id,
            validatedData
          );
          
          // Revalidate cache
          revalidatePath('/products');
          revalidatePath(`/products/${validatedData.id}`);
          
          return { success: true, data: product };
        } catch (error) {
          if (error instanceof z.ZodError) {
            return { success: false, error: 'Invalid input data' };
          }
          
          return { success: false, error: 'Failed to update product' };
        }
      }
      ```

      ### Server Action with FormData
      ```typescript
      'use server';

      import { z } from 'zod';
      import { revalidatePath } from 'next/cache';
      import { redirect } from 'next/navigation';
      import { PostService } from '@/services/PostService';

      const createPostSchema = z.object({
        title: z.string().min(1),
        content: z.string().min(10),
      });

      export async function createPost(formData: FormData) {
        try {
          const rawData = {
            title: formData.get('title'),
            content: formData.get('content'),
          };
          
          const validatedData = createPostSchema.parse(rawData);
          
          const postService = new PostService();
          const post = await postService.create(validatedData);
          
          revalidatePath('/posts');
          
          // Redirect after successful creation
          redirect(`/posts/${post.id}`);
        } catch (error) {
          if (error instanceof z.ZodError) {
            return { success: false, error: 'Invalid input data' };
          }
          
          return { success: false, error: 'Failed to create post' };
        }
      }
      ```

      ### Usage in Components
      ```typescript
      'use client';

      import { useState, useTransition } from 'react';
      import { createUser } from '@/actions/createUser';

      export default function CreateUserForm() {
        const [isPending, startTransition] = useTransition();
        const [error, setError] = useState<string | null>(null);

        async function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
          e.preventDefault();
          const formData = new FormData(e.currentTarget);
          
          startTransition(async () => {
            const result = await createUser({
              email: formData.get('email') as string,
              name: formData.get('name') as string,
            });
            
            if (!result.success) {
              setError(result.error || 'Failed to create user');
            } else {
              setError(null);
              // Handle success (e.g., show toast, reset form)
            }
          });
        }

        return (
          <form onSubmit={handleSubmit}>
            {/* Form fields */}
            <button type="submit" disabled={isPending}>
              {isPending ? 'Creating...' : 'Create User'}
            </button>
            {error && <p className="text-red-600">{error}</p>}
          </form>
        );
      }
      ```
  - name: service-layer-pattern
    design_pattern: Service Layer Pattern with Drizzle ORM
    includes:
      - src/services/**/*.ts
    description: |-
      ## Pattern Overview
      Design pattern for service classes that encapsulate business logic and database operations using Drizzle ORM with proper separation of concerns and dependency injection.

      ## What TO DO ✅

      - Create class-based services with clear single responsibility
      - Import db from '@/db/drizzle' for database access
      - Define service interfaces in src/services/types.ts
      - Use async/await for all database operations
      - Return typed results from service methods
      - Handle errors with try-catch and return error objects
      - Use Drizzle query builder for type-safe queries
      - Name methods with clear verbs (getById, create, update, delete, findBy...)
      - Keep services focused on single entity or domain
      - Use dependency injection for composing services
      - Export both interface and implementation

      ## What NOT TO DO ❌

      - Don't create static-only utility classes (use functions instead)
      - Don't mix multiple unrelated concerns in one service
      - Don't forget error handling
      - Don't expose Drizzle internals to callers
      - Don't use synchronous operations for database access
      - Don't create services without interfaces
      - Don't put UI logic or validation in services
      - Don't forget to export service interfaces from types.ts

      ## Examples

      ### Basic Service with CRUD Operations
      ```typescript
      import { db } from '@/db/drizzle';
      import { users } from '@/db/schema';
      import { eq } from 'drizzle-orm';
      import type { IUserService } from './types';

      export class UserService implements IUserService {
        async getById(id: string) {
          try {
            const user = await db
              .select()
              .from(users)
              .where(eq(users.id, id))
              .limit(1);
            
            return user[0] || null;
          } catch (error) {
            console.error('Failed to get user by id:', error);
            throw new Error('Failed to fetch user');
          }
        }

        async getAll() {
          try {
            return await db.select().from(users);
          } catch (error) {
            console.error('Failed to get all users:', error);
            throw new Error('Failed to fetch users');
          }
        }

        async create(data: { email: string; name: string }) {
          try {
            const result = await db
              .insert(users)
              .values(data)
              .returning();
            
            return result[0];
          } catch (error) {
            console.error('Failed to create user:', error);
            throw new Error('Failed to create user');
          }
        }

        async update(id: string, data: Partial<{ email: string; name: string }>) {
          try {
            const result = await db
              .update(users)
              .set(data)
              .where(eq(users.id, id))
              .returning();
            
            return result[0] || null;
          } catch (error) {
            console.error('Failed to update user:', error);
            throw new Error('Failed to update user');
          }
        }

        async delete(id: string) {
          try {
            await db.delete(users).where(eq(users.id, id));
            return true;
          } catch (error) {
            console.error('Failed to delete user:', error);
            throw new Error('Failed to delete user');
          }
        }
      }
      ```

      ### Service Interface Definition (types.ts)
      ```typescript
      export interface IUserService {
        getById(id: string): Promise<User | null>;
        getAll(): Promise<User[]>;
        create(data: { email: string; name: string }): Promise<User>;
        update(id: string, data: Partial<{ email: string; name: string }>): Promise<User | null>;
        delete(id: string): Promise<boolean>;
      }

      export interface IProductService {
        getById(id: string): Promise<Product | null>;
        findByCategory(category: string): Promise<Product[]>;
        create(data: CreateProductData): Promise<Product>;
        update(id: string, data: UpdateProductData): Promise<Product | null>;
        delete(id: string): Promise<boolean>;
      }
      ```

      ### Service with Complex Queries
      ```typescript
      import { db } from '@/db/drizzle';
      import { products, categories } from '@/db/schema';
      import { eq, and, gte, lte, desc } from 'drizzle-orm';
      import type { IProductService } from './types';

      export class ProductService implements IProductService {
        async getById(id: string) {
          try {
            const result = await db
              .select()
              .from(products)
              .leftJoin(categories, eq(products.categoryId, categories.id))
              .where(eq(products.id, id))
              .limit(1);
            
            return result[0] || null;
          } catch (error) {
            console.error('Failed to get product:', error);
            throw new Error('Failed to fetch product');
          }
        }

        async findByCategory(categoryId: string) {
          try {
            return await db
              .select()
              .from(products)
              .where(eq(products.categoryId, categoryId))
              .orderBy(desc(products.createdAt));
          } catch (error) {
            console.error('Failed to get products by category:', error);
            throw new Error('Failed to fetch products');
          }
        }

        async findByPriceRange(min: number, max: number) {
          try {
            return await db
              .select()
              .from(products)
              .where(and(gte(products.price, min), lte(products.price, max)))
              .orderBy(products.price);
          } catch (error) {
            console.error('Failed to get products by price range:', error);
            throw new Error('Failed to fetch products');
          }
        }

        async create(data: { name: string; price: number; categoryId: string }) {
          try {
            const result = await db
              .insert(products)
              .values(data)
              .returning();
            
            return result[0];
          } catch (error) {
            console.error('Failed to create product:', error);
            throw new Error('Failed to create product');
          }
        }
      }
      ```

      ### Service with Dependency Injection
      ```typescript
      import { db } from '@/db/drizzle';
      import { orders, orderItems } from '@/db/schema';
      import { eq } from 'drizzle-orm';
      import type { IOrderService, IProductService, IUserService } from './types';

      export class OrderService implements IOrderService {
        constructor(
          private productService: IProductService,
          private userService: IUserService
        ) {}

        async create(userId: string, items: Array<{ productId: string; quantity: number }>) {
          try {
            // Verify user exists
            const user = await this.userService.getById(userId);
            if (!user) {
              throw new Error('User not found');
            }

            // Verify all products exist
            for (const item of items) {
              const product = await this.productService.getById(item.productId);
              if (!product) {
                throw new Error(`Product ${item.productId} not found`);
              }
            }

            // Create order in transaction
            const result = await db.transaction(async (tx) => {
              const [order] = await tx
                .insert(orders)
                .values({ userId })
                .returning();

              const orderItemsData = items.map(item => ({
                orderId: order.id,
                productId: item.productId,
                quantity: item.quantity,
              }));

              await tx.insert(orderItems).values(orderItemsData);

              return order;
            });

            return result;
          } catch (error) {
            console.error('Failed to create order:', error);
            throw new Error('Failed to create order');
          }
        }
      }
      ```
  - name: drizzle-schema-pattern
    design_pattern: Drizzle ORM Database Schema Pattern
    includes:
      - src/db/**/*.ts
      - drizzle.config.ts
    description: |-
      ## Pattern Overview
      Design pattern for defining database schemas using Drizzle ORM with PostgreSQL, including proper column types, constraints, relationships, and indexing.

      ## What TO DO ✅

      - Import table builder from 'drizzle-orm/pg-core'
      - Use pgTable() to define tables with clear, descriptive names
      - Add timestamps (createdAt, updatedAt) to all tables
      - Use UUID or serial for primary keys
      - Define foreign key relationships with references()
      - Add proper indexes for frequently queried columns
      - Use TypeScript types for schema inference
      - Export schema types using typeof and InferSelectModel/InferInsertModel
      - Keep auth-related tables in separate schema file (auth-schema.ts)
      - Use descriptive column names in camelCase
      - Add default values where appropriate
      - Use correct PostgreSQL column types (uuid, timestamp, text, varchar, integer, boolean)

      ## What NOT TO DO ❌

      - Don't forget to export schemas from main schema.ts
      - Don't skip timestamps on tables
      - Don't use generic names like 'data' or 'info'
      - Don't forget to add indexes for foreign keys
      - Don't mix auth schema with application schema
      - Don't use incorrect column types (use varchar with length, not unlimited text for names)
      - Don't forget to run migrations after schema changes
      - Don't create circular dependencies between tables

      ## Examples

      ### Basic Table Schema
      ```typescript
      import { pgTable, text, timestamp, uuid, varchar } from 'drizzle-orm/pg-core';

      export const users = pgTable('users', {
        id: uuid('id').defaultRandom().primaryKey(),
        email: varchar('email', { length: 255 }).notNull().unique(),
        name: varchar('name', { length: 255 }).notNull(),
        createdAt: timestamp('created_at').defaultNow().notNull(),
        updatedAt: timestamp('updated_at').defaultNow().notNull(),
      });

      export type User = typeof users.$inferSelect;
      export type InsertUser = typeof users.$inferInsert;
      ```

      ### Table with Foreign Key Relations
      ```typescript
      import { pgTable, text, timestamp, uuid, varchar, integer } from 'drizzle-orm/pg-core';
      import { users } from './schema';

      export const posts = pgTable('posts', {
        id: uuid('id').defaultRandom().primaryKey(),
        title: varchar('title', { length: 255 }).notNull(),
        content: text('content').notNull(),
        userId: uuid('user_id')
          .notNull()
          .references(() => users.id, { onDelete: 'cascade' }),
        createdAt: timestamp('created_at').defaultNow().notNull(),
        updatedAt: timestamp('updated_at').defaultNow().notNull(),
      });

      export type Post = typeof posts.$inferSelect;
      export type InsertPost = typeof posts.$inferInsert;
      ```

      ### Table with Indexes
      ```typescript
      import { pgTable, text, timestamp, uuid, varchar, index } from 'drizzle-orm/pg-core';
      import { users } from './schema';

      export const products = pgTable(
        'products',
        {
          id: uuid('id').defaultRandom().primaryKey(),
          name: varchar('name', { length: 255 }).notNull(),
          slug: varchar('slug', { length: 255 }).notNull().unique(),
          categoryId: uuid('category_id').notNull(),
          price: integer('price').notNull(),
          createdAt: timestamp('created_at').defaultNow().notNull(),
          updatedAt: timestamp('updated_at').defaultNow().notNull(),
        },
        (table) => ({
          categoryIdx: index('category_idx').on(table.categoryId),
          slugIdx: index('slug_idx').on(table.slug),
        })
      );

      export type Product = typeof products.$inferSelect;
      export type InsertProduct = typeof products.$inferInsert;
      ```

      ### Database Client Setup (drizzle.ts)
      ```typescript
      import { drizzle } from 'drizzle-orm/neon-http';
      import { neon } from '@neondatabase/serverless';
      import * as schema from './schema';

      const sql = neon(process.env.DATABASE_URL!);

      export const db = drizzle(sql, { schema });
      ```

      ### Main Schema File Exports
      ```typescript
      // src/db/schema.ts
      import { pgTable, text, timestamp, uuid, varchar } from 'drizzle-orm/pg-core';

      // Application tables
      export const users = pgTable('users', {
        id: uuid('id').defaultRandom().primaryKey(),
        email: varchar('email', { length: 255 }).notNull().unique(),
        name: varchar('name', { length: 255 }).notNull(),
        createdAt: timestamp('created_at').defaultNow().notNull(),
        updatedAt: timestamp('updated_at').defaultNow().notNull(),
      });

      // Export auth schema (if using Better Auth)
      export * from './auth-schema';

      // Export types
      export type User = typeof users.$inferSelect;
      export type InsertUser = typeof users.$inferInsert;
      ```

      ### Drizzle Config
      ```typescript
      // drizzle.config.ts
      import { defineConfig } from 'drizzle-kit';

      export default defineConfig({
        schema: './src/db/schema.ts',
        out: './src/db/migrations',
        dialect: 'postgresql',
        dbCredentials: {
          url: process.env.DATABASE_URL!,
        },
      });
      ```

      ### Migration Workflow
      ```bash
      # 1. Define or update schema in src/db/schema.ts
      # 2. Generate migration
      pnpm db:generate

      # 3. Review generated migration in src/db/migrations/
      # 4. Apply migration
      pnpm db:migrate

      # 5. (Optional) Open Drizzle Studio to verify
      pnpm db:studio
      ```
  - name: better-auth-pattern
    design_pattern: Better Auth Configuration Pattern
    includes:
      - src/lib/auth.ts
      - src/lib/auth-client.ts
      - src/db/auth-schema.ts
      - middleware.ts
    description: |-
      ## Pattern Overview
      Design pattern for implementing Better Auth authentication with Drizzle adapter, proper server/client separation, and route protection patterns.

      ## What TO DO ✅

      - Separate server auth (auth.ts) from client auth (auth-client.ts)
      - Use Drizzle adapter with PostgreSQL
      - Configure auth providers in server auth only
      - Export typed client hooks from auth-client.ts
      - Add auth schema to separate file (auth-schema.ts)
      - Export auth tables from main schema.ts file
      - Use middleware.ts for route protection
      - Add session checks in protected layouts
      - Use headers() from next/headers for server-side session access
      - Configure BETTER_AUTH_SECRET and BETTER_AUTH_URL in environment
      - Add provider credentials for OAuth (GOOGLE_CLIENT_ID, etc.)

      ## What NOT TO DO ❌

      - Don't configure auth providers in client file
      - Don't access auth directly from client components (use hooks)
      - Don't forget to export auth schema from main schema
      - Don't skip database migration after adding auth schema
      - Don't hardcode secrets in code
      - Don't forget to protect routes with middleware or layout checks
      - Don't mix server and client auth code
      - Don't expose auth secrets to client

      ## Examples

      ### Server Auth Configuration (auth.ts)
      ```typescript
      import { betterAuth } from 'better-auth';
      import { drizzleAdapter } from 'better-auth/adapters/drizzle';
      import { db } from '@/db/drizzle';
      import * as schema from '@/db/schema';

      export const auth = betterAuth({
        database: drizzleAdapter(db, {
          provider: 'pg',
          schema,
        }),
        emailAndPassword: {
          enabled: true,
        },
        socialProviders: {
          google: {
            clientId: process.env.GOOGLE_CLIENT_ID!,
            clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
          },
          github: {
            clientId: process.env.GITHUB_CLIENT_ID!,
            clientSecret: process.env.GITHUB_CLIENT_SECRET!,
          },
        },
        secret: process.env.BETTER_AUTH_SECRET!,
        baseURL: process.env.BETTER_AUTH_URL!,
      });

      export type Session = typeof auth.$Infer.Session;
      ```

      ### Client Auth Configuration (auth-client.ts)
      ```typescript
      'use client';

      import { createAuthClient } from 'better-auth/react';

      export const authClient = createAuthClient({
        baseURL: process.env.NEXT_PUBLIC_BETTER_AUTH_URL!,
      });

      export const { useSession, signIn, signOut, signUp } = authClient;
      ```

      ### Auth Schema (auth-schema.ts)
      ```typescript
      import { pgTable, text, timestamp, uuid, boolean } from 'drizzle-orm/pg-core';

      export const user = pgTable('user', {
        id: uuid('id').defaultRandom().primaryKey(),
        name: text('name').notNull(),
        email: text('email').notNull().unique(),
        emailVerified: boolean('email_verified').notNull().default(false),
        image: text('image'),
        createdAt: timestamp('created_at').defaultNow().notNull(),
        updatedAt: timestamp('updated_at').defaultNow().notNull(),
      });

      export const session = pgTable('session', {
        id: uuid('id').defaultRandom().primaryKey(),
        userId: uuid('user_id')
          .notNull()
          .references(() => user.id, { onDelete: 'cascade' }),
        expiresAt: timestamp('expires_at').notNull(),
        token: text('token').notNull().unique(),
        ipAddress: text('ip_address'),
        userAgent: text('user_agent'),
        createdAt: timestamp('created_at').defaultNow().notNull(),
        updatedAt: timestamp('updated_at').defaultNow().notNull(),
      });

      export const account = pgTable('account', {
        id: uuid('id').defaultRandom().primaryKey(),
        userId: uuid('user_id')
          .notNull()
          .references(() => user.id, { onDelete: 'cascade' }),
        accountId: text('account_id').notNull(),
        providerId: text('provider_id').notNull(),
        accessToken: text('access_token'),
        refreshToken: text('refresh_token'),
        expiresAt: timestamp('expires_at'),
        createdAt: timestamp('created_at').defaultNow().notNull(),
        updatedAt: timestamp('updated_at').defaultNow().notNull(),
      });

      export const verification = pgTable('verification', {
        id: uuid('id').defaultRandom().primaryKey(),
        identifier: text('identifier').notNull(),
        value: text('value').notNull(),
        expiresAt: timestamp('expires_at').notNull(),
        createdAt: timestamp('created_at').defaultNow().notNull(),
        updatedAt: timestamp('updated_at').defaultNow().notNull(),
      });
      ```

      ### Protected Layout with Auth Check
      ```typescript
      import { auth } from '@/lib/auth';
      import { redirect } from 'next/navigation';
      import { headers } from 'next/headers';

      export default async function ProtectedLayout({
        children,
      }: {
        children: React.ReactNode;
      }) {
        const session = await auth.api.getSession({
          headers: await headers(),
        });

        if (!session) {
          redirect('/sign-in');
        }

        return (
          <div>
            <nav>
              <p>Welcome, {session.user.name}</p>
            </nav>
            <main>{children}</main>
          </div>
        );
      }
      ```

      ### Middleware for Route Protection
      ```typescript
      import { type NextRequest, NextResponse } from 'next/server';
      import { auth } from '@/lib/auth';

      export async function middleware(request: NextRequest) {
        const session = await auth.api.getSession({
          headers: request.headers,
        });

        const isProtectedRoute = request.nextUrl.pathname.startsWith('/dashboard');
        const isAuthRoute = request.nextUrl.pathname.startsWith('/sign-in');

        if (isProtectedRoute && !session) {
          return NextResponse.redirect(new URL('/sign-in', request.url));
        }

        if (isAuthRoute && session) {
          return NextResponse.redirect(new URL('/dashboard', request.url));
        }

        return NextResponse.next();
      }

      export const config = {
        matcher: ['/dashboard/:path*', '/sign-in', '/sign-up'],
      };
      ```

      ### Client Component with Auth Hooks
      ```typescript
      'use client';

      import { useSession, signOut } from '@/lib/auth-client';

      export default function UserProfile() {
        const { data: session, isPending } = useSession();

        if (isPending) {
          return <div>Loading...</div>;
        }

        if (!session) {
          return <div>Not authenticated</div>;
        }

        return (
          <div>
            <p>Logged in as {session.user.email}</p>
            <button onClick={() => signOut()}>Sign Out</button>
          </div>
        );
      }
      ```

      ### Environment Variables
      ```bash
      # .env.local
      DATABASE_URL=postgresql://...

      # Better Auth
      BETTER_AUTH_SECRET=your-secret-here  # Generate with: npx better-auth secret
      BETTER_AUTH_URL=http://localhost:3000
      NEXT_PUBLIC_BETTER_AUTH_URL=http://localhost:3000

      # OAuth Providers (optional)
      GOOGLE_CLIENT_ID=your-google-client-id
      GOOGLE_CLIENT_SECRET=your-google-client-secret
      GITHUB_CLIENT_ID=your-github-client-id
      GITHUB_CLIENT_SECRET=your-github-client-secret
      ```
