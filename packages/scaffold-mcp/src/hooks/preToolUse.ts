/**
 * PreToolUse Hook for Scaffold MCP
 *
 * DESIGN PATTERNS:
 * - Hook callback pattern: Executed before file write/edit operations
 * - Fail-open pattern: Errors allow operation to proceed with warning
 * - Single responsibility: Suggests scaffold methods for matching file patterns
 *
 * CODING STANDARDS:
 * - Export named callback function matching HookCallback signature
 * - Handle all errors gracefully with fail-open behavior
 * - Format messages clearly for LLM consumption
 *
 * AVOID:
 * - Blocking operations on errors
 * - Complex business logic (delegate to services)
 * - Mutating context object
 */

import type { HookCallback, HookContext, HookResponse } from '@agiflowai/hooks-adapter';
import { ExecutionLogService, DECISION_SKIP, DECISION_DENY } from '@agiflowai/hooks-adapter';
import { ProjectConfigResolver, TemplatesManagerService } from '@agiflowai/aicode-utils';
import { FileSystemService } from '../services/FileSystemService';
import { ScaffoldingMethodsService } from '../services/ScaffoldingMethodsService';
import path from 'node:path';
import { minimatch } from 'minimatch';

/**
 * PreToolUse hook callback for Scaffold MCP
 * Suggests scaffold methods when file matches scaffold feature patterns
 *
 * @param context - Normalized hook context
 * @returns Hook response with scaffold method suggestions
 */
export const preToolUseHook: HookCallback = async (context: HookContext): Promise<HookResponse> => {
  // Only process file write/edit operations
  if (!context.filePath) {
    return {
      decision: DECISION_SKIP,
      message: 'Not a file operation',
    };
  }

  try {
    // Find project root and check configuration
    const projectPath = await findProjectRoot(context.filePath);
    if (!projectPath) {
      return {
        decision: DECISION_SKIP,
        message: 'No project configuration found',
      };
    }

    // Check if this file was generated by scaffold - if so, skip suggestion
    const wasGenerated = await ExecutionLogService.wasGeneratedByScaffold(
      context.sessionId,
      context.filePath,
    );

    if (wasGenerated) {
      return {
        decision: DECISION_SKIP,
        message: 'File was generated by scaffold method, allowing manual edit',
      };
    }

    // Check if we already showed scaffold suggestion for this file in this session
    const alreadyShown = await ExecutionLogService.hasExecuted(
      context.sessionId,
      context.filePath,
      DECISION_DENY,
    );

    if (alreadyShown) {
      // Already showed suggestion - skip hook and let operation continue
      await ExecutionLogService.logExecution({
        sessionId: context.sessionId,
        filePath: context.filePath,
        operation: context.operation || 'unknown',
        decision: DECISION_SKIP,
      });

      return {
        decision: DECISION_SKIP,
        message: 'Scaffold suggestion already provided for this file',
      };
    }

    // Initialize scaffold services
    const templatesDir = await TemplatesManagerService.findTemplatesPath();
    const fileSystemService = new FileSystemService();
    const scaffoldingMethodsService = new ScaffoldingMethodsService(
      fileSystemService,
      templatesDir,
    );

    // Get all scaffold methods for this project
    let allMethods: any[] = [];
    let cursor: string | undefined;
    do {
      const result = await scaffoldingMethodsService.listScaffoldingMethods(projectPath, cursor);
      allMethods = allMethods.concat(result.methods);
      cursor = result.nextCursor;
    } while (cursor);

    if (allMethods.length === 0) {
      return {
        decision: DECISION_SKIP,
        message: 'No scaffold methods available for this project',
      };
    }

    // Check if file matches any scaffold feature patterns
    const relativePath = path.relative(projectPath, context.filePath);
    const matchedMethods = allMethods.filter((method) => {
      if (!method.patterns || method.patterns.length === 0) {
        return false;
      }

      return method.patterns.some((pattern: string) => {
        return minimatch(relativePath, pattern, { matchBase: true });
      });
    });

    if (matchedMethods.length > 0) {
      // File matches scaffold patterns - suggest using scaffold method
      let message = `⚠️ This file matches scaffold feature patterns. Consider using a scaffold method instead of writing manually:\n\n`;

      for (const method of matchedMethods) {
        message += `**${method.name}**\n`;
        message += `${method.instruction || method.description}\n`;
        message += `Patterns: ${method.patterns.join(', ')}\n\n`;

        if (method.variables_schema.required && method.variables_schema.required.length > 0) {
          message += `Required variables: ${method.variables_schema.required.join(', ')}\n`;
        }

        message += '\n**To use this scaffold method:**\n';
        message += '```typescript\n';
        message += `// Call the use-scaffold-method tool with:\n`;
        message += `{\n`;
        message += `  projectPath: "${projectPath}",\n`;
        message += `  scaffold_feature_name: "${method.name}",\n`;
        message += `  variables: { /* provide required variables */ }\n`;
        message += `}\n`;
        message += '```\n\n';
      }

      message += `**Note:** If you intentionally want to write this file manually (not using scaffold), you can proceed. This suggestion will not be shown again for this file.`;

      // Log that we showed scaffold suggestion
      await ExecutionLogService.logExecution({
        sessionId: context.sessionId,
        filePath: context.filePath,
        operation: context.operation || 'unknown',
        decision: DECISION_DENY,
      });

      return {
        decision: DECISION_DENY,
        message,
      };
    }

    // No pattern match - suggest listing available methods
    let message = `ℹ️ No scaffold method found for this file path.\n\n`;
    message += `Available scaffold methods for this project:\n\n`;

    for (const method of allMethods.slice(0, 5)) {
      // Show first 5
      message += `- **${method.name}**: ${method.description}\n`;
    }

    if (allMethods.length > 5) {
      message += `\n...and ${allMethods.length - 5} more methods.\n`;
    }

    message += `\n**To see full details:**\n`;
    message += `Call the list-scaffolding-methods tool with projectPath: "${projectPath}"\n\n`;
    message += `**Note:** This is just an informational suggestion. You can proceed with writing the file manually.`;

    // Log that we showed general scaffold info
    await ExecutionLogService.logExecution({
      sessionId: context.sessionId,
      filePath: context.filePath,
      operation: context.operation || 'unknown',
      decision: DECISION_DENY,
    });

    return {
      decision: DECISION_DENY,
      message,
    };
  } catch (error) {
    // Fail open: skip hook and let operation continue
    return {
      decision: DECISION_SKIP,
      message: `⚠️ Hook error: ${error instanceof Error ? error.message : String(error)}`,
    };
  }
};

/**
 * Find project root by looking for project configuration
 */
async function findProjectRoot(filePath: string): Promise<string | null> {
  let currentDir = path.dirname(filePath);
  const root = path.parse(currentDir).root;

  while (currentDir !== root) {
    const hasConfig = await ProjectConfigResolver.hasConfiguration(currentDir);
    if (hasConfig) {
      return currentDir;
    }
    currentDir = path.dirname(currentDir);
  }

  return null;
}
