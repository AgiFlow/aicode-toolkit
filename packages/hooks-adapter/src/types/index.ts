/**
 * @agiflowai/hooks-adapter - Type Definitions
 *
 * DESIGN PATTERNS:
 * - Interface segregation: Keep interfaces focused and minimal
 * - Type composition: Build complex types from simple primitives
 * - Generics: Use type parameters for reusable, type-safe abstractions
 *
 * CODING STANDARDS:
 * - Use PascalCase for type/interface names
 * - Prefix interfaces with 'I' only for abstract contracts
 * - Document complex types with JSDoc comments
 * - Export all public types
 *
 * AVOID:
 * - Any type unless absolutely necessary
 * - Overly complex type gymnastics
 * - Coupling types to implementation details
 */

/**
 * Decision types for hook responses
 */
export type Decision = 'allow' | 'deny' | 'ask' | 'skip';

/**
 * Normalized hook context passed to hook callbacks
 * Provides a common interface for hooks regardless of the underlying AI agent format
 */
export interface HookContext {
  /** Name of the tool being executed (e.g., 'Read', 'Write', 'Edit') */
  toolName: string;

  /** Input parameters for the tool */
  toolInput: Record<string, unknown>;

  /** File path for file operations (extracted from tool input if applicable) */
  filePath?: string;

  /** Operation type for file operations */
  operation?: 'read' | 'write' | 'edit';

  /** Current working directory */
  cwd: string;

  /** Unique session identifier */
  sessionId: string;

  /** Optional LLM tool identifier (e.g., 'claude-code') */
  llmTool?: string;
}

/**
 * Response from hook callback function
 */
export interface HookResponse {
  /** Permission decision for the tool execution */
  decision: Decision;

  /** Message shown to the LLM (e.g., design patterns, warnings) */
  message: string;

  /** Optional message shown only to the user (not the LLM) */
  userMessage?: string;

  /** Optional updated input parameters for the tool */
  updatedInput?: Record<string, unknown>;
}

// Tool Result Types (for PostToolUse hooks)

/**
 * Content item in tool result from Claude Code
 */
export interface ToolResultContentItem {
  /** Content type (e.g., 'text', 'image') */
  readonly type: string;
  /** Text content if type is 'text' */
  readonly text?: string;
}

/**
 * Tool result structure from Claude Code PostToolUse hook
 */
export interface ToolResult {
  /** Array of content items returned by the tool */
  readonly content?: readonly ToolResultContentItem[];
}

// Scaffold Execution Types

/**
 * Scaffold execution data from execution log
 */
export interface ScaffoldExecution {
  /** Unique scaffold execution ID */
  readonly scaffoldId: string;
  /** List of files generated by the scaffold */
  readonly generatedFiles: readonly string[];
  /** Name of the scaffold feature/method */
  readonly featureName?: string;
}

/**
 * Log entry structure from ExecutionLogService
 */
export interface LogEntry {
  /** Timestamp of the log entry */
  readonly timestamp?: number;
  /** Session ID */
  readonly sessionId?: string;
  /** Operation type */
  readonly operation: string;
  /** Scaffold execution ID */
  readonly scaffoldId?: string;
  /** Files generated by scaffold */
  readonly generatedFiles?: readonly string[];
  /** Scaffold feature name */
  readonly featureName?: string;
  /** File path */
  readonly filePath: string;
  /** Decision made */
  readonly decision?: string;
  /** File pattern matched */
  readonly filePattern?: string;
  /** File modification timestamp */
  readonly fileMtime?: number;
  /** File content checksum */
  readonly fileChecksum?: string;
  /** Project path */
  readonly projectPath?: string;
}

/**
 * Pending scaffold log entry for temp file storage
 */
export interface PendingScaffoldLogEntry {
  /** Unique scaffold execution ID */
  readonly scaffoldId: string;
  /** List of files generated */
  readonly generatedFiles: readonly string[];
  /** Project path where scaffold was executed */
  readonly projectPath: string;
  /** Scaffold feature name */
  readonly featureName?: string;
}
