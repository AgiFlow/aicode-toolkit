/**
 * ExecutionLogService - Tracks hook executions to prevent duplicate actions
 *
 * DESIGN PATTERNS:
 * - Repository pattern: Abstracts data access to execution log
 * - Query pattern: Provides efficient lookups for hook execution history
 * - Singleton cache: In-memory cache for performance
 *
 * CODING STANDARDS:
 * - Use static methods for stateless operations
 * - Handle file system errors gracefully
 * - Optimize for performance with efficient data structures
 *
 * AVOID:
 * - Loading entire log file into memory
 * - Blocking I/O operations
 * - Complex parsing logic (keep it simple)
 */

import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import * as os from 'node:os';
import * as crypto from 'node:crypto';

/**
 * Log entry structure for hook execution
 */
interface HookLogEntry {
  timestamp: number;
  sessionId: string;
  filePath: string;
  operation: string;
  decision: string;
  filePattern?: string;
  /** File modification timestamp (mtime) at time of execution */
  fileMtime?: number;
  /** MD5 checksum of file content at time of execution */
  fileChecksum?: string;
  /** List of files generated by scaffold method execution */
  generatedFiles?: string[];
  /** Unique scaffold execution ID (for tracking specific scaffold operations) */
  scaffoldId?: string;
  /** Project path where scaffold was executed */
  projectPath?: string;
  /** Name of the scaffold feature/method that was used */
  featureName?: string;
}

/**
 * Input parameters for logging a hook execution
 */
export interface LogExecutionParams {
  sessionId: string;
  filePath: string;
  operation: string;
  decision: string;
  filePattern?: string;
  /** File modification timestamp (mtime) at time of execution */
  fileMtime?: number;
  /** MD5 checksum of file content at time of execution */
  fileChecksum?: string;
  /** List of files generated by scaffold method execution */
  generatedFiles?: string[];
  /** Unique scaffold execution ID (for tracking specific scaffold operations) */
  scaffoldId?: string;
  /** Project path where scaffold was executed */
  projectPath?: string;
  /** Name of the scaffold feature/method that was used */
  featureName?: string;
}

/**
 * Service for tracking hook executions using an append-only log
 * Prevents duplicate hook actions (e.g., showing design patterns twice for same file)
 * Each session has its own log file for isolation
 */
export class ExecutionLogService {
  /** Log file path for this session - stored in system temp directory */
  private readonly logFile: string;

  /** In-memory cache of recent executions (last 1000 entries) */
  private cache: HookLogEntry[] | null = null;

  /** Max cache size to prevent memory bloat */
  private static readonly MAX_CACHE_SIZE = 1000;

  /** Session ID for this service instance */
  private readonly sessionId: string;

  /**
   * Create a new ExecutionLogService instance for a specific session
   * @param sessionId - Unique session identifier
   */
  constructor(sessionId: string) {
    this.sessionId = sessionId;
    this.logFile = path.join(os.tmpdir(), `hook-adapter-executions-${sessionId}.jsonl`);
  }

  /**
   * Check if a specific action was already taken for this file in this session
   *
   * @param filePath - File path to check
   * @param decision - Decision to check for (e.g., 'deny' means we already showed patterns)
   * @param filePattern - Optional file pattern to match
   * @returns true if the action was already taken
   */
  async hasExecuted(filePath: string, decision: string, filePattern?: string): Promise<boolean> {
    const entries = await this.loadLog();

    // Search from end (most recent) for efficiency
    for (let i = entries.length - 1; i >= 0; i--) {
      const entry = entries[i];

      const matchedFile =
        (entry.filePattern === filePattern && entry.filePattern && filePattern) ||
        entry.filePath === filePath;
      // Match file and decision (session is already filtered by log file)
      if (entry.decision === decision && matchedFile) {
        return true;
      }
    }

    return false;
  }

  /**
   * Log a hook execution
   *
   * @param params - Log execution parameters (sessionId will be set automatically)
   */
  async logExecution(params: Omit<LogExecutionParams, 'sessionId'>): Promise<void> {
    const entry: HookLogEntry = {
      timestamp: Date.now(),
      sessionId: this.sessionId,
      filePath: params.filePath,
      operation: params.operation,
      decision: params.decision,
      filePattern: params.filePattern,
      fileMtime: params.fileMtime,
      fileChecksum: params.fileChecksum,
      generatedFiles: params.generatedFiles,
      scaffoldId: params.scaffoldId,
      projectPath: params.projectPath,
      featureName: params.featureName,
    };

    // Append to log file (JSONL format - one JSON object per line)
    try {
      await fs.appendFile(this.logFile, `${JSON.stringify(entry)}\n`, 'utf-8');

      // Update cache
      if (this.cache) {
        this.cache.push(entry);
        // Trim cache if too large
        if (this.cache.length > ExecutionLogService.MAX_CACHE_SIZE) {
          this.cache = this.cache.slice(-ExecutionLogService.MAX_CACHE_SIZE);
        }
      }
    } catch (error) {
      // Fail silently - logging should not break the hook
      console.error('Failed to log hook execution:', error);
    }
  }

  /**
   * Load execution log from file
   * Uses in-memory cache for performance
   */
  private async loadLog(): Promise<HookLogEntry[]> {
    // Return cached data if available
    if (this.cache !== null) {
      return this.cache;
    }

    try {
      // Read log file
      const content = await fs.readFile(this.logFile, 'utf-8');

      // Parse JSONL format
      const lines = content.trim().split('\n').filter(Boolean);
      const entries: HookLogEntry[] = [];

      for (const line of lines) {
        try {
          entries.push(JSON.parse(line));
        } catch {}
      }

      // Keep only recent entries to prevent memory bloat
      this.cache = entries.slice(-ExecutionLogService.MAX_CACHE_SIZE);
      return this.cache;
    } catch (error: any) {
      // File doesn't exist yet or read error - start with empty log
      if (error.code === 'ENOENT') {
        this.cache = [];
        return this.cache;
      }

      // Other errors - fail silently and return empty
      console.error('Failed to load execution log:', error);
      this.cache = [];
      return this.cache;
    }
  }

  /**
   * Clear the execution log (for testing)
   */
  async clearLog(): Promise<void> {
    try {
      await fs.unlink(this.logFile);
      this.cache = [];
    } catch (error: any) {
      if (error.code !== 'ENOENT') {
        throw error;
      }
    }
  }

  /**
   * Get log statistics (for debugging)
   */
  async getStats(): Promise<{
    totalEntries: number;
    uniqueFiles: number;
  }> {
    const entries = await this.loadLog();
    const files = new Set(entries.map((e) => e.filePath));

    return {
      totalEntries: entries.length,
      uniqueFiles: files.size,
    };
  }

  /**
   * Get file metadata (mtime and checksum) for a file
   *
   * @param filePath - Path to the file
   * @returns File metadata or null if file doesn't exist
   */
  async getFileMetadata(filePath: string): Promise<{ mtime: number; checksum: string } | null> {
    try {
      // Read file content first to compute checksum - this is the authoritative value
      // for detecting changes. We get mtime after for optimization purposes.
      // Note: There's a theoretical race between read and stat, but the checksum
      // (computed from actual content read) is what we use for change detection.
      const content = await fs.readFile(filePath, 'utf-8');
      const checksum = crypto.createHash('md5').update(content).digest('hex');
      const stats = await fs.stat(filePath);

      return {
        mtime: stats.mtimeMs,
        checksum,
      };
    } catch {
      return null;
    }
  }

  /**
   * Check if a file has changed since the last execution for this session
   * Returns true if the file should be reviewed (new file or content changed)
   *
   * @param filePath - File path to check
   * @param decision - Decision type to check for
   * @returns true if file has changed or no previous execution found
   */
  async hasFileChanged(filePath: string, decision: string): Promise<boolean> {
    const entries = await this.loadLog();

    // Find the most recent execution for this file/decision
    let lastExecution: HookLogEntry | null = null;
    for (let i = entries.length - 1; i >= 0; i--) {
      const entry = entries[i];
      if (entry.filePath === filePath && entry.decision === decision) {
        lastExecution = entry;
        break;
      }
    }

    // No previous execution - file should be reviewed
    if (!lastExecution || !lastExecution.fileChecksum) {
      return true;
    }

    // Get current file metadata
    const currentMetadata = await this.getFileMetadata(filePath);
    if (!currentMetadata) {
      return true; // File doesn't exist, let hook handle it
    }

    // Compare checksum - if different, file has changed
    return currentMetadata.checksum !== lastExecution.fileChecksum;
  }

  /**
   * Check if file was recently reviewed (within debounce window)
   * Prevents noisy feedback during rapid successive edits
   *
   * @param filePath - File path to check
   * @param debounceMs - Debounce window in milliseconds (default: 3000ms = 3 seconds)
   * @returns true if file was reviewed within debounce window
   */
  async wasRecentlyReviewed(filePath: string, debounceMs = 3000): Promise<boolean> {
    try {
      const entries = await this.loadLog();
      const now = Date.now();

      // Search from end (most recent) for efficiency
      for (let i = entries.length - 1; i >= 0; i--) {
        const entry = entries[i];

        // Match file
        if (entry.filePath === filePath) {
          // Check if this review was recent (within debounce window)
          const timeSinceLastReview = now - entry.timestamp;
          if (timeSinceLastReview < debounceMs) {
            return true;
          }

          // Found an entry but it's old enough - allow review
          return false;
        }
      }

      // No previous review found - allow review
      return false;
    } catch (error) {
      // On error, fail open - allow review
      console.error('Error checking recent review:', error);
      return false;
    }
  }

  /**
   * Check if a file was generated by a scaffold method
   * Useful for hooks to avoid suggesting scaffold for files already created by scaffold
   *
   * @param filePath - File path to check
   * @returns true if file was generated by scaffold in this session
   */
  async wasGeneratedByScaffold(filePath: string): Promise<boolean> {
    try {
      const entries = await this.loadLog();

      // Search from end (most recent) for efficiency
      for (let i = entries.length - 1; i >= 0; i--) {
        const entry = entries[i];

        // Only check scaffold operations
        if (entry.operation === 'scaffold') {
          // Check if this file is in the generatedFiles list
          if (entry.generatedFiles && entry.generatedFiles.includes(filePath)) {
            return true;
          }
        }
      }

      return false;
    } catch (error) {
      // On error, fail open - return false
      console.error('Error checking if file was generated by scaffold:', error);
      return false;
    }
  }
}
